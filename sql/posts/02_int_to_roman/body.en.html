<p>Here we are going to look at how to parse an interger and convert it to it's equivalent Roman numeral. To achieve this, we must first understand Ruman numerals themselves and how to convert them.</p>

<h2>About Roman Numerals</h2>

<p>I won't go into too much detail on the history or why the Roman Numerals. If you like, you can read all about that in <a target="_blank" href="https://en.wikipedia.org/wiki/Roman_numerals">wikipedia</a>.</p>
<p>If you look closely to roman numerals, you will find that they are in fact, decimal. What that means is, all though there is no unique symbol for each digit, there is a unique template for each digit.</p>

<p>To illustrate, let's display all the roman numerals and numbers from 1 to 9 and beside it, multiples of 10 starting from 10 to 90:</p>
<table>
	<thead>
		<tr>
			<th>Number</th>
			<th>Roman Numeral</th>
			<th>&nbsp;</th>
			<th>Number</th>
			<th>Roman Numeral</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>1</td>
			<td>I</td>
			<td></td>
			<td>10</td>
			<td>X</td>
		</tr>
		<tr>
			<td>2</td>
			<td>II</td>
			<td></td>
			<td>20</td>
			<td>XX</td>
		</tr>
		<tr>
			<td>3</td>
			<td>III</td>
			<td></td>
			<td>30</td>
			<td>XXX</td>
		</tr>
		<tr>
			<td>4</td>
			<td>IV</td>
			<td></td>
			<td>40</td>
			<td>XL</td>
		</tr>
		<tr>
			<td>5</td>
			<td>V</td>
			<td></td>
			<td>50</td>
			<td>L</td>
		</tr>
		<tr>
			<td>6</td>
			<td>VI</td>
			<td></td>
			<td>60</td>
			<td>LX</td>
		</tr>
		<tr>
			<td>7</td>
			<td>VII</td>
			<td></td>
			<td>70</td>
			<td>LXX</td>
		</tr>
		<tr>
			<td>8</td>
			<td>VIII</td>
			<td></td>
			<td>80</td>
			<td>LXXX</td>
		</tr>
		<tr>
			<td>9</td>
			<td>IX</td>
			<td></td>
			<td>90</td>
			<td>XC</td>
		</tr>
	</tbody>
</table>

<p>Hopefully, you look at the table and you start noticing a pattern. The roman numerals share common traits between the single digits and their corresponding digit multiplied by 10. For example, the difference between 3 and 30 is that instead of Is we use Xs. The difference between 8 and 80 is that instead of a Vs and an Is, we use a Ls and Xs. This pattern repeats all the way up to 3999, which is the maximum number we can represent in Roman.</p>

<p>So, let's look at the complete table, that includes single digits, multiples of 10, 100 and 1000.</p>


<table>
	<thead>
		<tr>
			<th>Digit</th>
			<th>10<sup>0</sup></th>
			<th>10<sup>1</sup></th>
			<th>10<sup>2</sup></th>
			<th>10<sup>3</sup></th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>1</td>
			<td>I</td>
			<td>X</td>
			<td>C</td>
			<td>M</td>
		</tr>
		<tr>
			<td>2</td>
			<td>II</td>
			<td>XX</td>
			<td>CC</td>
			<td>MM</td>
		</tr>
		<tr>
			<td>3</td>
			<td>III</td>
			<td>XXX</td>
			<td>CCC</td>
			<td>MMM</td>
		</tr>
		<tr>
			<td>4</td>
			<td>IV</td>
			<td>XL</td>
			<td>CD</td>
			<td></td>
		</tr>
		<tr>
			<td>5</td>
			<td>V</td>
			<td>L</td>
			<td>D</td>
			<td></td>
		</tr>
		<tr>
			<td>6</td>
			<td>VI</td>
			<td>LX</td>
			<td>DC</td>
			<td></td>
		</tr>
		<tr>
			<td>7</td>
			<td>VII</td>
			<td>LXX</td>
			<td>DCC</td>
			<td></td>
		</tr>
		<tr>
			<td>8</td>
			<td>VIII</td>
			<td>LXXX</td>
			<td>DCCC</td>
			<td></td>
		</tr>
		<tr>
			<td>8</td>
			<td>IX</td>
			<td>XC</td>
			<td>CM</td>
			<td></td>
		</tr>
	</tbody>
</table>

<p>Now, with this more elaborate table, we can not only see the patterns of each power of 10, but also, we can build any roman numeral out of any decimal number. So, let's say the number 2345:</p>
<code>
	<p>2345 = 2000 + 300 + 40 + 5</p>
	<p>2345 = 2*1000 + 3*100 + 4*10 + 5*1</p>
	<p>2345 = 2*10<sup>3</sup> + 3*10<sup>2</sup> + 4*10<sup>1</sup> + 5*10<sup>0</sup></p>
</code>
<p>We can now find each numeral by matching the digit with the power of 10:</p>
<code>
	<p>2345 = MM + CCC + XL + V</p>
	<p>2345 = MMCCCXLV</p>
</code>

<p>So, in summary, this is how we convert from numbers to roman numerals: <b>We cycle through each digit and convert it to it's corresponding roman compound according to it's power of 10.</b></p>

<h2>Wait! What about zeros?</h2>

<p>Mhh... good question! What about zeros? Well, the short answer is, just ignore the zeros. for example: the roman numeral for 802 is 800 + 2, or 8*10<sup>2</sup> + 2*10<sup>0</sup>, which is LCCC + II, or LCCCII. As you can see, none of the 'tens' roman symbols are in the number.</p>

<p>As for the long answer, and as you may all ready know, roman numerals do not have a representation of zero. Another way of interpreting it is that roman numerals Do in fact have a zero, and that is actually represented by '' (empty string), but this would clearly be cause for ambiguity. The fact is, not having a zeromay well be the defining reason for why the roman numerals have so many limitations. In other words, not having a zero made thing very hard for those roman counters. You may not realize it now, but hopefuly you will by the end of reading this and/or making the algorithm.</p>

<h2>Before we start coding</h2>

<p>keep in mind that I will be using <b>C++</b> to code the solution. It should, however, be easy to port to any other language, such as Java or C#.</p>

<h2>Begin coding!</h2>

<h3>Code setup.</h3>

<p>This will be a very simple command line tool. We start by having a simple main function:</p>
<code>
<b>
//main.cpp<br/>
#include &lt;iostream&gt;<br/>
<br/>
int main(int argc, const char *argv[]) {<br/>
	<br/>
}<br/>
</b>
</code>
<h3>The Roman class</h3>
<p>Just for kicks, we will use a bit of object orientated design. we will create a class only for the pourpose of converting from a positive integer to a roman string. So let's create a new class called <b>Roman</b> in <b>Roman.hpp</b>:</p>
<code>
//Roman.hpp<br/><b>
#include &lt;string&gt;<br/>
<br/>
using namespace std;<br/>
<br/>
class Roman {<br/>
private:<br/>
&nbsp; &nbsp; static char symbols[4][3];<br/>
&nbsp; &nbsp; char buffer[16];<br/>
&nbsp; &nbsp; void digit(int &k, int d, char i, char v, char x);<br/>

<br/>
public:<br/>
&nbsp; &nbsp; string intToRoman(int n);<br/>
};<br/>
<br/></b>
</code>

<p>The first thing we notice is a static variable <b>symbols</b>, a matrix of chars. This is a table that stores all available combinations of roman letters that correspond to each individual digit of a number. For example: to convert the first, or least significant digit of any number we would need 3 chars: I, V and X, the same goes for the second digit or tens, which use X, L and C, and so on.</p>

<p>The second thing we notice is a <b>buffer</b> private variable, an array of chars. That is where we will store our roman numeral while we are parsing the integer. In the end, the buffer will be copied into a string and returned. The buffer is private because there is no need for it to be public, since we will return a copy of it.</p>

<p>Third, we notice the <b>digit</b> private method. This method is in charge of converting a single digit into it's corresponding roman numeral. Let's look at its parameters: Variable <b>k</b> is the index of the buffer where we are storing the current roman numeral, and it is passed by reference so we can keep track of it from the outside. Input <b>d</b> is the digit to convert,  a number between 0 and 9. 0 will be ignored, and any other digit will be converted. We also see three chars, <b>i</b>, <b>v</b> and <b>x</b>. Those are the corresponding roman symbols we will use. Essentialy, these symbols will change depending on where in the number is the digit we are converting.</p>
<p>Finally, we notice the <b>intToRoman</b> public method, this is the method that will cycle through and convert each digit, one by one.</p>

<h3>Defining the symbols table</h3>
<p>Now we move to the implementation of the Roman class, the <b>Roman.cpp</b> file, where the first thing we will do is define the symbols table.</p>
<code>
//Roman.cpp<br/>
<b>
char Roman::symbols[4][3] = {<br/>
&nbsp; &nbsp; {'I','V','X'},<br/>
&nbsp; &nbsp; {'X','L','C'},<br/>
&nbsp; &nbsp; {'C','D','M'},<br/>
&nbsp; &nbsp; {'M','?','?'}<br/>
};<br/>
</b>
</code>
<p>As we mentioned before, we will use this table to determine which letters to use during the conversion of a single digit. The letters we use will be determined by the power of 10 we are curently examining. if we start from the least significant digit to the most significant digit, that would mean that the first digit, we want to use index zero, for which 10<sup>0</sup> corresponds to the letters I, V and X, which is exactly what we want. The next index 1 (10<sup>1</sup>) will yield the letters X, L and C.</p>

<h3>Converting each digit</h3>
<p>This is probably the coolest part of the algorithm. It's the part that does the convertion. It is the most complicated part of the whole algorithm, but it is actually not that complicated. In fact, it is very simple. All we have to do is convert directly each digit. A switch works well enough, and depending on what digit we get, we convert directly. We define the method <b>digit</b> to do just that.</p>
<code>
//Roman.cpp<br/>
char Roman::symbols[4][3] = {<br/>
&nbsp; &nbsp; {'I','V','X'},<br/>
&nbsp; &nbsp; {'X','L','C'},<br/>
&nbsp; &nbsp; {'C','D','M'},<br/>
&nbsp; &nbsp; {'M','?','?'}<br/>
};<br/>
<br/><b>
void Roman::digit(int &k, int d, char i, char v, char x) {<br/>
&nbsp; &nbsp; switch(d) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; case 1:<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer[--k] = i;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; case 2:<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer[--k] = i;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer[--k] = i;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; case 3:<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer[--k] = i;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer[--k] = i;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer[--k] = i;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; case 4:<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer[--k] = v;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer[--k] = i;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; case 5:<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer[--k] = v;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; case 6:<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer[--k] = i;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer[--k] = v;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; case 7:<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer[--k] = i;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer[--k] = i;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer[--k] = v;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; case 8:<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer[--k] = i;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer[--k] = i;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer[--k] = i;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer[--k] = v;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; case 9:<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer[--k] = x;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer[--k] = i;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; case 0:<br/>
&nbsp; &nbsp; &nbsp; &nbsp; default:<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br/>
&nbsp; &nbsp; }<br/>
}<br/>
</b>
</code>
<p>And with that, we can now convert each digit accurately, provided that we set the correct letters as the parameters. Notice how we assign each letter in inverse order. For example: in the case of digit 8, we first assign the 3 Is and finally the V, this is because we are saving the number in the buffer starting from the end to the beggining. In other words, we start with the least significant digit and work our way backwards, so we begin by placing the roman numerals at the end and in inverse order.</p>
<h3>Cycling through each digit</h3>
<p>Now that we have the digit method, we must call it for each digit and make sure the correct letters are being used.</p>
<code>
//Roman.cpp<br/>
char Roman::symbols[4][3] = {<br/>
&nbsp; &nbsp; {'I','V','X'},<br/>
&nbsp; &nbsp; {'X','L','C'},<br/>
&nbsp; &nbsp; {'C','D','M'},<br/>
&nbsp; &nbsp; {'M','?','?'}<br/>
};<br/>
<br/>
void Roman::digit(int &k, int d, char i, char v, char x) {<br/>
&nbsp; &nbsp; switch(d) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; case 1:<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer[--k] = i;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; case 2:<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer[--k] = i;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer[--k] = i;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; case 3:<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer[--k] = i;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer[--k] = i;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer[--k] = i;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; case 4:<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer[--k] = v;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer[--k] = i;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; case 5:<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer[--k] = v;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; case 6:<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer[--k] = i;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer[--k] = v;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; case 7:<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer[--k] = i;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer[--k] = i;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer[--k] = v;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; case 8:<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer[--k] = i;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer[--k] = i;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer[--k] = i;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer[--k] = v;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; case 9:<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer[--k] = x;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer[--k] = i;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; case 0:<br/>
&nbsp; &nbsp; &nbsp; &nbsp; default:<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br/>
&nbsp; &nbsp; }<br/>
}<br/>
<br/><b>
string Roman::intToRoman(int n) {<br/>
&nbsp; &nbsp; //d is the current digit<br/>
&nbsp; &nbsp; int d;<br/>
&nbsp; &nbsp; //start from the end<br/>
&nbsp; &nbsp; int k = ROMAN_BUF;<br/>
&nbsp; &nbsp; //make sure the last char is end of string '\0'<br/>
&nbsp; &nbsp; buffer[--k] = '\0';<br/>
&nbsp; &nbsp; //t is the exponent, it determines which table to use<br/>
&nbsp; &nbsp; int t = 0;<br/>
&nbsp; &nbsp; while (n>0) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; d = n%10;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; n = n/10;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; digit(k, d, symbols[t][0], symbols[t][1], symbols[t][2]);<br/>
&nbsp; &nbsp; &nbsp; &nbsp; t++;<br/>
&nbsp; &nbsp; }<br/>
&nbsp; &nbsp; return string(&buffer[k]);<br/>
}<br/></b>
</code>
<p>And at this point, we are practically done. All we have to do now is call the method in the entry point.</p>

<code>
//main.cpp<br/>
#include &lt;iostream&gt;<br/>
<b>#include "Roman.hpp"</b><br/>
<br/>
int main(int argc, const char *argv[]) {<br/><b>
&nbsp; &nbsp; Roman roman;<br/>
&nbsp; &nbsp; cout&lt;&lt;roman.intToRoman(2345)&lt;&lt;endl;<br/>
</b>
}<br/>
</b>
</code>
<p>And that is it. In the sample we print out the roman value of 2345, which should be <b>MMCCCXLV</b>.</p>
<p>Now it is up to you to read the number from the input, or whatever you want to do.</p>
<h2>My thoughts and conclusions</h2>
<p>I can say that I thought I understood roman numerals before I solved this problem, which was not too long ago. It's almost embarrasing at this point. But then again, it's not like we use roman numerals in our daily lives, so I can hope that I deserve a little redemption.</p>

<p>After unerstanding roman numerals, I understood their limitations: by not having a zero, the roman people were forced to change the digit template everytime a new letter was being appended, otherwise there was no way to distinguish between 1 (I), 10 (X) or 100 (C). If they had a zero, however, we would not need new symbols everytime we append a digit, and we could represent 10 with I0, and 400 with IV00. You may be able to see now that if the roman numerals had a zero, we would only need those first ten ruman numerals and zero to create the rest. But alas, I don't it is my understanding that romans at the time could not even grasp the concept of zero.</p>

<p>The roman numerals use 7 letters of the english alphabet (I, V, X, L, C and M) which forces onto the roman numeral an upper limit of 3999. So I wondered, had the Roman numerals used all the letters en the english alphabet (26 in total), how much would the upper limit increase?</p>

<p>Well, for 7 digits we can calculate the following way:</p>

<ol>
	<li>Let's call the number of letters we have available M.</li>
	<li>We can separate the number of letters M between N and R.</li>
	<li>N is equal to M if M is even, otherwise it is equal to M-1 if M is odd. In this case, M=7, it is odd, therefore, N=6.</li>
	<li>R is 1 minus the modulus between N and 2. In laymans terms, R=1 if M is even, and R=0 if M is odd.</li>
	<li>And now we can calculate:</li>
</ol>

<p>Roman Numeral Ceiling = (10<sup>N/2</sup> - 1) + 3*10<sup>N/2</sup> + R*5*(10<sup>N/2)</sup></p>
<p>So in the case of 7, N=6, and R=0:</p>
<p>Roman Numeral Ceiling = (10<sup>|6/2|</sup> - 1) + 3*10<sup>6/2</sup> + 1*5*(10<sup>6/2</sup>)</p>
<p>Roman Numeral Ceiling = (10<sup>3</sup> - 1) + 3*10<sup>3</sup> + 0*5*(10<sup>3</sup>)</p>
<p>Roman Numeral Ceiling = (1000 - 1) + 3000</p>
<p>Roman Numeral Ceiling = 999 + 3000</p>
<p>Roman Numeral Ceiling = 3999</p>

<p>So if we use 7 letters to represent Roman Numerals, we get that we can represent a maximum of 3999 different numbers.</p>
<p>So, what if we use 26 letters? Well, since 26 is even, N=26 and R=1:</p>

<p>Roman Numeral Ceiling = (10<sup>26/2</sup> - 1) + 3*10<sup>26/2</sup> + 1*5*(10<sup>26/2)</sup></p>

<p>Roman Numeral Ceiling = (10<sup>13</sup> - 1) + 3*10<sup>13</sup> + 5*(10<sup>13</sup>)</p>

<p>Roman Numeral Ceiling = (10,000,000,000,000 - 1) + 3*10,000,000,000,000 + 5*(10,000,000,000,000)</p>

<p>Roman Numeral Ceiling = 9,999,999,999,999 + 30,000,000,000,000 + 50,000,000,000,000</p>

<p>Roman Numeral Ceiling = 89,999,999,999,999</p>

<p>So for 26 letters, we can produce Roman-like numerals that would reach a maximum number that, we can call, of almost 90 trillion in the <a href="https://en.wikipedia.org/wiki/Long_and_short_scales">short scale</a>, or 90 billion in the <a href="https://en.wikipedia.org/wiki/Long_and_short_scales">long scale</a>.</p>

<p>And that is it. If you like, you can download the C++ code in <a href="{{ URL::Asset('code/02_intToRoman.zip') }}">this link</a>. The code is in C++ language and should work on most, if not any C++ compilers. I hope this article helps you in any way.</p>