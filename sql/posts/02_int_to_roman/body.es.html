<p>Aquí, vamos a mirar como se convierte un número entero a su equivalente número romano. Para lograr esto, primero debemos entender como funcionan los números romanos, y luego como convertirlos</p>

<h2>Acerca de Números Romanos</h2>

<p>No entraré en mucho detalle sobre los números romanos y su historia. Si prefieres, puedes leer sobre todo eso en este articulo de <a target="_blank" href="https://es.wikipedia.org/wiki/Numeraci%C3%B3n_romana">wikipedia</a>.</p>

<p>Si miras de cerca a los números romanos, encontraras que estos son ed su defecto, decimales, y se puede decir que para cada dígito decimal de una secuencia de dígitos (ej: 123), existe una representación romana (CXXIII). Es decir, aun cuando cada dígito de una secuencia de números romanos no comparte las mismas letras, cada dígito de una secuencia de numerales romanos si comparte una plantilla de letras.</p>

<p>Para ilustrar, desplegamos una table de números romanos y números decimales del 1 al 9, y al lado la misma pero de múltiplos de 10 y sys representación en romano.</p>

<table>
	<thead>
		<tr>
			<th>Number</th><th>Roman</th><th>&nbsp;</th><th>Number</th><th>Roman</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<th>1</th><td>I</td><td></td><th>10</th><td>X</td>
		</tr>
		<tr>
			<th>2</th><td>II</td><td></td><th>20</th><td>XX</td>
		</tr>
		<tr>
			<th>3</th><td>III</td><td></td><th>30</th><td>XXX</td>
		</tr>
		<tr>
			<th>4</th><td>IV</td><td></td><th>40</th><td>XL</td>
		</tr>
		<tr>
			<th>5</th><td>V</td><td></td><th>50</th><td>L</td>
		</tr>
		<tr>
			<th>6</th><td>VI</td><td></td><th>60</th><td>LX</td>
		</tr>
		<tr>
			<th>7</th><td>VII</td><td></td><th>70</th><td>LXX</td>
		</tr>
		<tr>
			<th>8</th><td>VIII</td><td></td><th>80</th><td>LXXX</td>
		</tr>
		<tr>
			<th>9</th><td>IX</td><td></td><th>90</th><td>XC</td>
		</tr>
	</tbody>
</table>

<p>Quizás, que al ver esta tabla empiezas a reconocer un patrón. Los números romanos 1 al 9 comparten la misma combinación de letras con los múltiplos de 10, que van del 10 al 90, aunque no las letras en si. Por ejemplo, la diferencia entre el 3 y el 30 es que en vez de usar Is, utilizamos Xs. La diferencia entre el 8 y el 80 es que en vex de utilizar Vs y Is, utilizamos Ls y Xs. Este patrón se repite hasta llegar al limite de 3999, el número romano mas grande que se puede representar.</p>

<p>Así que, veamos la tabla completa que incluye todos los dígitos, y adicionalmente, los múltipos de 10, 100 y 1000.</p>

<table>
	<thead>
		<tr>
			<th>Dígito</th>
			<th>10<sup>3</sup></th>
			<th>10<sup>2</sup></th>
			<th>10<sup>1</sup></th>
			<th>10<sup>0</sup></th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<th>0</th><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td>
		</tr>
		<tr>
			<th>1</th><td>M</td><td>C</td><td>X</td><td>I</td>
		</tr>
		<tr>
			<th>2</th><td>MM</td><td>CC</td><td>XX</td><td>II</td>
		</tr>
		<tr>
			<th>3</th><td>MMM</td><td>CCC</td><td>XXX</td><td>III</td>
		</tr>
		<tr>
			<th>4</th><td></td><td>CD</td><td>XL</td><td>IV</td>
		</tr>
		<tr>
			<th>5</th><td></td><td>D</td><td>L</td><td>V</td>
		</tr>
		<tr>
			<th>6</th><td></td><td>DC</td><td>LX</td><td>VI</td>
		</tr>
		<tr>
			<th>7</th><td></td><td>DCC</td><td>LXX</td><td>VII</td>
		</tr>
		<tr>
			<th>8</th><td></td><td>DCCC</td><td>LXXX</td><td>VIII</td>
		</tr>
		<tr>
			<th>9</th><td></td><td>CM</td><td>XC</td><td>IX</td>
		</tr>
	</tbody>
</table>

<p>Ahora, con esta tabla mas elaborada, no solo vemos el patron de cada potencia de 10, sino también podemos construir números romanos de cualquier decimal.</p>

<p>Entonces, si deseamos convertir el número <b>2345</b> a romanos:</p>
<pre><code>
	2345 = 2000 + 300 + 40 + 5
	2345 = 2*1000 + 3*100 + 4*10 + 5*1
	2345 = 2*10<sup>3</sup> + 3*10<sup>2</sup> + 4*10<sup>1</sup> + 5*10<sup>0</sup>
</code></pre>
<p>Ahora podemos utilizar la tabla para buscar cada dígito romano:</p>
<pre><code>
	2345 = MM + CCC + XL + V
	2345 = MMCCCXLV
</code></pre>

<p>En resumen, así es como convertimos de números enteros a romanos: <b>Miramos cada dígito del número entero y lo convertimos a su romano correspondiente de acuerdo a su potencia de 10.</b></p>

<h2>¡Espera! ¿Y que hay de los zeros?</h2>

<p>Mhh... ¡Buena pregunta! ¿Que hay de los zeros? Pues, la respuesta corta es, solo ignóralos. Por ejemplo: El número romano para 802 se deduce por sumar 800 + 2, o 8*10<sup>2</sup> + 2*10<sup>0</sup>, los cuales corresponden a LCCC + II, o bien, LCCCII. Como puedes ver, el numeral no contiene ninguno de los 'dieces' (X, XX, XXX, etc....).</p>

<p>En cuanto a la respuesta larga, y como te habrás dado cuenta, los números romanos no tienen representación para el zero, o bien, otra forma de interpretarlo es que si la tienen y es equivalente a '' (cadena vacía). Esta ultimo seria, por supuesto, muy ambiguo. Sea cual sea la forma en que lo interpretes lo cierto es que el no tener zero podría ser la razón de porque los números romanos tienen tantas limitaciones. Quizá no te des cuenta ahora, pero quizá después de leer hasta el final, o luego de hacer el algoritmo, lo comprenderás.</p>

<h2>Antes de codificar</h2>

<h3>Ilustración del algoritmo</h3>
<p>La siguiente secuencia anulada ilustra mas o menos que es lo que el algoritmo va a hacer. En la ilustración, convertimos el numero 2904 a romano, recorriendo cada dígito y convirtiéndolo directamente, empezando por el menos significativo al mas significativo (de derecha a izquierda).</p>

<p style="text-align: center;"><img src="/images/gifs/algorithm_int_to_roman.gif" alt="Algorithm to convert integer number 2904 to roman numerals."/></p>

<p>Ten en cuenta que el código se escribirá en lenguaje <b>C++</b>. Igual, sería muy fácil de portar a cualquier otro lenguaje.</p>

<h2>Empezando a codificar</h2>

<h3>Estado inicial del código</h3>

<p>Este ejemplo será una simple aplicación de linea de comando. Empezamos por una simple función main de entrada:</p>

<pre><code>//main.cpp
#include &lt;iostream&gt;

int main(int argc, const char *argv[]) {
	
}
</code></pre>

<h3>La clase Roman</h3>
<p>Por diversion, vamos a hacer uso de diseño de programación orientado a objetos, creando una clase solo para convertir a números romanos, de un entero a una cadena de caracteres (string). Así que construyamos una clase llamada <b>Roman</b> y la declaramos en el archivo <b>Roman.hpp</b>:</p>

<pre><code>//Roman.hpp
#include &lt;string&gt;

using namespace std;

class Roman {
private:
	static char symbols[4][3];
	char buffer[16];
	void digit(int &k, int d, char i, char v, char x);


public:
	string intToRoman(int n);
};</code></pre>

<p>Lo primero que notamos es la variable estática <b>symbols</b>, una matriz de caractéres. Esta tabla almacenará todas las letras que se utilizaran para convertir de decimal a romano. Por ejemplo, si queremos convertir un de un dígito (0 al 9) a romano, necesitaremos 3 letras: I, V y X. Si queremos convertir un múltiplo de 10, del 10 al 90, utilizaremos también 3 letras pero distintas: X, L, C; y así sucesivamente. Toda la tabla se puede resumir de la siguiente manera:</p>

<ul>
	<li>Para 10<sup>0</sup>: utiliza I, V y X</li>
	<li>Para 10<sup>1</sup>: utiliza X, L y C</li>
	<li>Para 10<sup>2</sup>: utiliza C, D y M</li>
	<li>Para 10<sup>3</sup>: utiliza M, y se nos acabaron las letras</li>
</ul>

<p>Lo segundo que notamos es la variable privada <b>buffer</b>, un arreglo de caractéres. Allí es donde almacenaremos el número romano como string, mientras recorremos el número decimal. Al final, dicho buffer será copiado a un string y este será devuelto.</p>

<p>Tercéro, notamos el método privado <b>digit</b>. Este método estará a cargo de convertir un dígito independiente a su correspondiente secuencia romana. Miremos a sis parámetros: La variable <b>k</b> es el índice del arreglo (buffer) en donde almacenamos el número romano, y se pasa por referencia debido a que necesitamos llevar registro de por donde vamos y en donde quedamos luego de terminar una conversión. Le sigue el entero <b>d</b>, que no es mas que el dígito a convertir, un numero entre 0 y 9, donde el 0 se ignorará, y el resto se convertirán directamente. Luego vemos 3 caracteres: <b>i</b>, <b>v</b> y <b>x</b>. Estos son las letras que utilizaremos para convertir el dígito a romano. Esencialmente, estas letras serán distintas dependiendo de en que posición del número decimal se encuentra el dígito que estamos convirtiendo.</p>

<p>Finalmente, vemos a el método público <b>intToRoman</b>, que será el que obtendrá cada dígito y lo convertirá uno por uno.</p>

<h3>Definiendo la tabla de símbolos</h3>

<p>Ahora nos dirigimos a la implementación de la clase Roman, en el archivo <b>Roman.cpp</b>, en donde lo primero que hacemos es definir la tabla de símbolos.</p>

<pre><code>//Roman.cpp

#include "Roman.hpp"

char Roman::symbols[4][3] = {
	{'I','V','X'},
	{'X','L','C'},
	{'C','D','M'},
	{'M','?','?'}
};</code></pre>

<p>Como lo mencionamos anteriormente, utilizaremos esta tabla para determinar que letras utilizar al convertir cada dígito. Cada fila corresponde al exponente de 10 que corresponde al dígito en cuestión. Por ejemplo, la primera fila, o fila zero (0), corresponde a las letras utilizadas por el coeficiente de 10<sup>0</sup> (I, V y X), que es una forma bonita para llamar al dígito menos significativo, o el primer dígito de derecha a izquierda. Para los coeficientes de 10<sup>1</sup>, utilizamos las letras X, L y C, y así sucesivamente.</p>

<h3>Convirtiendo cada dígito</h3>

<p>Este es, quizá, la parte las interesante del algoritmo. Es la parte en donde convertimos cada dígito independientemente, y es quizá, la parte mas complicada de todo el algoritmo. Pero en realidad no es complicada. ¡Es mas! ¡Es bastante simple! Lo único que hay que hacer es convertir cada dígito directamente. Un <i>'switch'</i> sería suficiente. Así que definimos el método <b>digit</b> de la siguiente manera:</p>

<pre><code>//Roman.cpp
[...]
void Roman::digit(int &amp;k, int d, char i, char v, char x) {
	switch(d) {
		case 1:
			buffer[--k] = i;
			break;
		case 2:
			buffer[--k] = i;
			buffer[--k] = i;
			break;
		case 3:
			buffer[--k] = i;
			buffer[--k] = i;
			buffer[--k] = i;
			break;
		case 4:
			buffer[--k] = v;
			buffer[--k] = i;
			break;
		case 5:
			buffer[--k] = v;
			break;
		case 6:
			buffer[--k] = i;
			buffer[--k] = v;
			break;
		case 7:
			buffer[--k] = i;
			buffer[--k] = i;
			buffer[--k] = v;
			break;
		case 8:
			buffer[--k] = i;
			buffer[--k] = i;
			buffer[--k] = i;
			buffer[--k] = v;
			break;
		case 9:
			buffer[--k] = x;
			buffer[--k] = i;
			break;
		case 0:
		default:
			break;
	}
}</code></pre>

<p>Y ahora con esto, podemos convertir cada dígito, siempre y cuando entreguemos las letras correctas como parámetros. Nótese que asignamos las letras en orden inverso, eso es porque estamos recorriendo de derecha a izquierda. Es decir, dese el último dígito hasta el primero, por lo tanto empezamos desde el final, el dígito menos significativo, hasta llegar al primero, el dígito mas significativo. Por ejemplo, para convertir el 8 (VIII) empezamos desde el final, y asignamos en  orden inverso I, I, I y V.</p>

<h3>Procesando cada dígito</h3>

<p>Ahora que tenemos el método digit funcionando, debemos llamarlo una vez por cada dígito, y asegurar que utilizamos las letras correctas.</p>

<pre><code>//Roman.cpp
[...]
string Roman::intToRoman(int n) {
	//d es el dígito que estamos procesando
	int d;
	//empezamos desde el final del buffer
	int k = ROMAN_BUF;
	//Aseguramos que el último caracter es '\0' (fin de cadena)
	buffer[--k] = '\0';
	//t es el exponente, o bien, la fila de la tabla
	int t = 0;
	while (n>0) {
		d = n%10;
		n = n/10;
		digit(k, d, symbols[t][0], symbols[t][1], symbols[t][2]);
		t++;
	}
	return string(&buffer[k]);
}</code></pre>
<p>El algoritmo recorre los dígitos empezando por el menos significativo y divide el numero en 10, de tal forma que en cada ciclo obtenemos el dígito siguiente, hasta llegar al mas significativo, que es cuando, al dividir, nos da el resultado de zero.</p>

<p>Y hasta este punto, hemos terminado. Ahora llamar el método y ver los resultados.</p>
<pre><code>//main.cpp
#include &lt;iostream&gt;
#include "Roman.hpp"

int main(int argc, const char *argv[]) {
	Roman roman;
	cout&lt;&lt;roman.intToRoman(2345)&lt;&lt;endl;

}</code></pre>

<p>Y eso es todo. En la muestra de arriba, desplegamos en pantalla el valor romano de 2345, que debe ser <b>MMCCCXLV</b>.</p>

<p>Ahora está a tu discreción si deseas leer el número de la entrada, o sea lo que sea que quieras hacer.</p>

<h2>Calculando la cota superior asistótica (Big-O)</h2>

<p>Calcular la eficiencia del algoritmo es relativamente fácil. Inicialmente se puede ver que hay un ciclo repetitivo, lo que sugiere que podría haber algo de complejidad en el algoritmo. Iniciemos por decir que vamos a calcular T(N) donde N es la cantidad de dígitos que contiene el número decimal que se va a convertir a romano.</p>
<pre><code>T(N) = O(N)</code></pre>
<p>Entonces T(N) = O(N), sin embargo, No es posible convertir números mas grandes que que 3999, por lo tanto, N no puede tener mas de 4 dígitos:</p>
<pre><code>T(N) = O(4)
T(N) = O(1)</code></pre>

<p>Entonces la cota superior asistótica es en realidad O(1), lo que en general significa que siempre consume la misma cantidad de tiempo al ejecutarse. Existe un limite sobre cuantos números se pueden convertir a romanos, y por lo tanto, la complejidad no es un factor.</p>

<h2>Conclusiones y Pensamientos</h2>

<p>Puedo decir que pensé que entendía números romanos antes de resolver este problema, lo cual no fue hace mucho tiempo. Es penoso para mi admitirlo a estas alturas. Pero por otro lado, yo no utilizo números romanos en mi vida diaria, así que espero merecer un poco de redención.</p>

<p>Luego de comprender los números romanos, comprendí sus limitaciones: Al no tener zero, los romanos estaban obligados a cambiar las letras cada vez que querían anexar un nuevo dígito a un numero. De otra manera, no habría forma de distinguir entre, por ejemplo, 4 (IV), 40 (XL) y 400 (CD). Si los números romanos tuvieran zero, solo necesitaríamos los primeros 10 números romanos para representar el resto, de la misma manera que lo hacemos con los dígitos. Por ejemplo: el 6 (VI), se le anexaría un zero para ser 60 (VI0), igual al 600 (VI00), o al 6000 (IV000). No obstante, la historia indica que los romanos no podían ni conceptualizar el zero, mucho menos incluirlo en su sistema de numeración.</p>

<h3>El límite superior de los Números Romanos</h3>

<p>Los números romanos hacen uso de 7 letras del alfabeto ingles (I, V, X, L, C y M), lo cual obliga que tengan un límite superior de 3999. Así que me hice la pregunta: ¿Si los números romanos hicieran uso de las 26 letras del alfabeto ingles, cuantos números romanos se podrían generar?</p>

<p>Pues bien, hagamos el ejercicio para 7 letras. La formula para calcularlos sería la siguiente, donde N es la cantidad de letras a utilizar:</p>

<pre><code>//Corchetes [] significa la parte entera, así que [4.56] es igual a 4.

//Porcentaje % es la operación módulo, que corresponde
//al sobrante de una division. Ej:
//7%2=1 (7/2 = 3 y sobra <b>1</b>)
//6%2=0 (6/2 = 3 y sobra <b>0</b>)

Limite_Superior_Romano = (10<sup>[N/2]</sup> - 1) + (3 + 5+(1 - N%2))*10<sup>[N/2]</sup>

//Así que, para cuando N = 7:
Limite_Superior_Romano = (10<sup>[7/2]</sup> - 1) + (3 + 5*(1 - 7%2))*10<sup>[7/2]</sup>
Limite_Superior_Romano = (10<sup>[3.5]</sup> - 1) + (3 + 5*(1 - 1))*10<sup>[3.5]</sup>
Limite_Superior_Romano = (10<sup>3</sup> - 1) + 3*10<sup>3</sup>
Limite_Superior_Romano = (1000 - 1) + 3*1000
Limite_Superior_Romano = 999 + 3000
Limite_Superior_Romano = 3999</code></pre>

<p>Así que como los números romanos utilizan 7 letras, podemos representar hasta 3999 diferentes números romanos.</p>

<p>¿Y si utilizamos 26 letras? ¡Averiguémoslo!</p>

<pre><code>Limite_Superior_Romano = (10<sup>[26/2]</sup> - 1) + (3 + 5*(1 - 26%2))*10<sup>[26/2]</sup>
Limite_Superior_Romano = (10<sup>13</sup> - 1) + (3 + 5*(1 - 0))*10<sup>13</sup>
Limite_Superior_Romano = (10<sup>13</sup> - 1) + 8*10<sup>13</sup>
Limite_Superior_Romano = (10,000,000,000,000 - 1) + 80,000,000,000,000
Limite_Superior_Romano = 9,999,999,999,999 + 80,000,000,000,000
Limite_Superior_Romano = 89,999,999,999,999</code></pre>

<p>Así que para 26 letras, podemos producir algo similar a números romanos que alcanzarían hasta casi 90 trillones (<a href="https://es.wikipedia.org/wiki/Escalas_num%C3%A9ricas_larga_y_corta#Escala_num.C3.A9rica_larga">escala larga</a>).</p>

<p>Y... ¡Hemos terminado! Si deseas, puedes descargar el código en C++ con <a href="/code/02_intToRoman.zip">este enlace</a>. El código debería compilar bien en cualquier compilador de C++. Espero que este artículo haya ayudado a alguien de cualquier forma.</p>